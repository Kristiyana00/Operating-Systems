Вашата задача ще е да имплементирате виртуална машина с памет с произволен
достъп.

Без паника!

Виртуалната машина ще бъде извиквана по следния начин:

    ./main program.orc

Където program.orc е файл във формат ORC (измислен за целите на тази задача),
съдържащ "машинният код" - програмата, която вашата виртуална машина трябва да
изпълни. В директория examples/ имате няколко примерни програми.

Една програма има следната структура:

- (char[3])  - магическата дума "ORC"
- (uint32_t) - числото ram_size, което посочва колко клетки памет трябва да има
               на разположение машината, докато изпълнява програмата (*1)
- останалата част от програмата е последователност от инструкции.

Всяка инструкция има размер 25 байта. Първият байт на всяка инструкция е
нейният opcode (число, което третираме като "номер" на инструкцията в таблицата
по-долу), а останалите 24 байта са операнди на инструкцията. Всички операнди са
от тип int64_t, а ако инструкцията използва по-малко от 3 операнда,
неизползваните се игнорират.

Програмата оперира върху памет с размер ram_size на брой клетки, като всяка
клетка е от тип int64_t. Клетките са номерирани, и казваме, че имат "адреси":
първата клетка е с адрес 0, втората с адрес 1 и т.н.

Ето таблица с всички възможни инструкции (колонката "име" е само информативна и
не е пряко свързана с решението):

opcode  име     операнди        описание
================================================================================
0x00    nop                     не прави нищо

0x95    set     tar, val        записваме стойността val в клетка с адрес tar

0x5d    load    to, from_ptr    копираме стойността от клетката с адрес
                                стойността в клетката from_ptr в
                                клетката с адрес to

0x63    store   to_ptr, from    копираме стойността от клетката с адрес
                                from в клетката с адрес стойността на клетката
                                to_ptr

0x91    jmp     idx             скачаме на инструкция с адрес стойността
                                на клетката с адрес idx и
                                продължаваме изпълнението от там
                                (първата инструкция в програмата е с номер 0
                                и т.н.)

0x25    sgz      v              ако стойността на клетката с адрес v е > 0,
                                пропускаме следващата инструкция

0xAD    add     res, v1, v2     в клетката с адрес res записваме сбора на
                                числата в клетките с адреси v1 и v2

0x33    mul     res, v1, v2     в клетката с адрес res записваме произведението
                                на числата в клетките с адреси v1 и v2

0x04    div     res, v1, v2     в клетката с адрес res записваме частното
                                на числата в клетките с адреси v1 и v2
                                (*2)

0xB5    mod     res, v1, v2     в клетката с адрес res записваме остатъка
                                на числата в клетките с адреси v1 и v2
                                (*2)

0xC1    out     v               на stdout извеждаме символа с ascii код числото
                                в клетката с адрес v

0xBF    sleep   v               блокираме изпълнението за толкова милисекунди,
                                колкото е числото в клетката с адрес v
================================================================================

Виртуалналната машина изпълнява инструкциите, започвайки от първата инструкция
в програмата, и след всяка инструкция (освен jmp) преминава на следващата.

Когато изпълним последната инструкция от програмата, виртуалната машина
приключва изпълнението си успешно. Ако по време на изпълнение се е случила
грешка, виртуалната машина приключва с неуспех. Възможни грешки са "невалиден
адрес", "деление на 0", "невалидна инструкция", и др.

За компилиране на вашата програма е предоставен Makefile. Може да го редактирате
за да добавяте допълнителни .c файлове към вашия код, но нямате право да променяте
флаговете за компилаторни грешки. Програмата ви трябва да се компилира успешно
с въпросния Makefile.

(*1) - това означава, че можем да алокираме цялата памет в началото, което е
       за улеснение.
(*2) - дели се на стойността на клетката с адрес v2.
